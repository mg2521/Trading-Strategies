# -*- coding: utf-8 -*-
"""Momentum Turning Points.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dx26HCzVmp9VxcDupRvKUkzsCd4i02yR
"""

import numpy as np
import random
import tensorflow as tf
from collections import deque
import pandas as pd
from matplotlib import pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from scipy.interpolate import make_interp_spline
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import holidays
import datetime

fp=pd.read_excel('/content/Final Port.xlsx')
vix=pd.read_excel('/content/VIX_Ind.xlsx')
vix=vix.iloc[::-1].reset_index(drop=True)

fp.Dates=pd.to_datetime(fp.Dates,format="%Y-%m-%d")
vix.Date=pd.to_datetime(vix.Date,format="%Y-%m-%d")

forwards=fp[['Dates','BCN3M Curncy','CZK3M Curncy','KWN3M Curncy','NOK3M Curncy','PLN3M Curncy','SEK3M Curncy','HUF3M Curncy','AUD3M Curncy','HKD3M Curncy','EURCZK3M Curncy',
             'BCN1M Curncy','CZK1M Curncy','KWN1M Curncy','NOK1M Curncy','PLN1M Curncy','SEK1M Curncy','HUF1M Curncy','AUD1M Curncy','HKD1M Curncy','EURCZK1M Curncy']]
forwards=forwards.set_index('Dates')
forwards.index=pd.to_datetime(forwards.index,format="%Y-%m-%d")
spot=pd.read_excel('/content/Spot.xlsx')
spot=spot.set_index('Dates')
spot.index=pd.to_datetime(spot.index,format="%Y-%m-%d")
forwards=forwards.rename({'BCN3M Curncy':'BRL3M Curncy','BCN1M Curncy':'BRL1M Curncy','KWN3M Curncy':'KRW3M Curncy','KWN1M Curncy':'KRW1M Curncy'},axis='columns')
forwards1=forwards

fwd_tickers=['BRL','CZK','KRW','NOK','PLN','SEK','HUF','AUD','HKD','EURCZK']
for i in fwd_tickers:
  forwards[f'{i}3M Curncy']=(forwards[f'{i}3M Curncy']/10000)+spot[f'{i} Curncy']
  forwards[f'{i}1M Curncy']=(forwards[f'{i}1M Curncy']/10000)+spot[f'{i} Curncy']
forwards

forwards=forwards.loc[forwards.index>=pd.to_datetime('2001-01-01')]
forwards

vix=vix.set_index('Date')
vix.index=pd.to_datetime(vix.index,format="%Y-%m-%d")
vix.columns=['VIX']

vix=vix.pct_change()
vix=vix.dropna()
vix['MA120']=vix.VIX.rolling(window=120).mean()
vix=vix.loc[(vix.index>=pd.to_datetime("2001-01-01",format='%Y-%m-%d'))&(vix.index<=pd.to_datetime("2023-09-01",format='%Y-%m-%d'))]
vix

fp=fp.set_index('Dates')


fp.index=pd.to_datetime(fp.index,format="%Y-%m-%d")
fp=fp.drop(columns=['BCN3M Curncy','CLNI3M Curncy','ZAR3M Curncy','CZK3M Curncy','KWN3M Curncy','NOK3M Curncy','PLN3M Curncy','SEK3M Curncy','HUF3M Curncy','AUD3M Curncy','HKD3M Curncy','EURCZK3M Curncy',
                    'BCN1M Curncy','CZK1M Curncy','CLNI1M Curncy','ZAR1M Curncy','KWN1M Curncy','NOK1M Curncy','PLN1M Curncy','SEK1M Curncy','HUF1M Curncy','AUD1M Curncy','HKD1M Curncy','EURCZK1M Curncy'])
fp=pd.concat([fp,forwards],axis=1)

fp=fp.loc[(fp.index>=pd.to_datetime("2001-01-01",format='%Y-%m-%d'))&(fp.index<=pd.to_datetime("2023-09-01",format='%Y-%m-%d'))]

#fp=fp.drop(fp.loc[fp.index.isin(df.index)].index)
fp1=fp.pct_change()
fp1=fp1.dropna()
list_fwd=['BRL3M Curncy','CZK3M Curncy','KRW3M Curncy','NOK3M Curncy','PLN3M Curncy','SEK3M Curncy','HUF3M Curncy','AUD3M Curncy','HKD3M Curncy','EURCZK3M Curncy']
for j in list_fwd:
  ticker1=j
  ticker1=ticker1.replace('3M','1M')
  fp[f'{j}_carry']=pd.DataFrame(((fp[j]/fp[ticker1])-1)*(1/61))
  fp1[j]=fp1[j]+fp[f'{j}_carry'].shift(1)
fp1

fp1=fp1.dropna()
fp1=pd.concat([fp1,vix],axis=1)
fp1

fp1=fp1.dropna()
fp1

vix_f=fp1.iloc[:,33:35]
vix_f=vix_f.fillna(0)

fi=['FV1 Comdty','TY1 Comdty','CN1 Comdty','XM1 Comdty','TU1 Comdty','RX1 Comdty']
agri=['KC1 Comdty', 'CT1 Comdty','C 1 Comdty','LH1 Comdty', 'LC1 Comdty','W 1 Comdty','SB1 Comdty','QC1 Comdty','CC1 Comdty', 'BO1 Comdty','FC1 Comdty','O 1 Comdty']
ener=['CO1 Comdty','HO1 Comdty','CL1 Comdty','QS1 Comdty','NG1 Comdty']
met=['HG1 Comdty','GC1 Comdty','PA1 Comdty','PL1 Comdty','SI1 Comdty','LX1 Comdty']
curncy=['CD1 Curncy','BP1 Curncy', 'AD1 Curncy', 'JY1 Curncy','SF1 Curncy','CZK3M Curncy','KRW3M Curncy',
        'NOK3M Curncy','PLN3M Curncy','SEK3M Curncy','HUF3M Curncy','AUD3M Curncy','HKD3M Curncy','EURCZK3M Curncy']
eq=['CF1 Index','Z 1 Index','IB1 Index','PT1 Index','ES1 Index','GX1 Index','SM1 Index','NQ1 Index','NK1 Index','VG1 Index','HI1 Index']
rates=['ER4 Comdty','ER8 Comdty','IR2 Comdty','BA8 Comdty']
fi_p=fp1.loc[:,fi]
agri_p=fp1.loc[:,agri]
ener_p=fp1.loc[:,ener]
met_p=fp1.loc[:,met]
cur_p=fp1.loc[:,curncy]
eq_p=fp1.loc[:,eq]
rates_p=fp1.loc[:,rates]
fi_p=fi_p.dropna()
agri_p=agri_p.dropna()
ener_p=ener_p.dropna()
met_p=met_p.dropna()
cur_p=cur_p.dropna()
eq_p=eq_p.dropna()
rates_p=rates_p.dropna()

lags1=[225,230,245,255,260]
lags2=[42,63,84,105,126]
optimal_weights1=[0.01,0.08,0.11,0.38,0.42]
optimal_weights2=[0.2,0.2,0.2,0.2,0.2]

basket_final=pd.DataFrame()
basket_returns={}

def calc_vol(returns):
  half_life_6_days = 65
  half_life_24_days = 120

  # Initialize DataFrame to hold results
  results_df = pd.DataFrame(columns=['Date', 'Final Estimate'])

  # Iterate through each day
  for i in range(len(returns)):
    if i >= half_life_24_days:
      window_data = returns[i-half_life_24_days+1:i+1]  # Get data for the rolling window
  # Calculate estimates based on different half-lives
      estimate_6_days = window_data.ewm(span=half_life_6_days, min_periods=half_life_6_days).std()
      estimate_24_days = window_data.ewm(span=half_life_24_days, min_periods=half_life_24_days).std()

  # Calculate final estimate as described (maximum of 6-day and 24-day estimate * 0.5)
      final_estimate = max(estimate_6_days.iloc[-1], estimate_24_days.iloc[-1] * 0.5)

    # Record date and final estimate
      result_row = {'Date': returns.index[i], 'Vol': final_estimate}
      results_df = results_df.append(result_row, ignore_index=True)
  results_df=results_df.set_index('Date')
  results_df.index=pd.to_datetime(results_df.index,format='%Y-%m-%d')
  return results_df

def signal_boost2(signal,vix):
  signal=pd.concat([signal,vix],axis=1)
  signal=signal.dropna()
  for i in range(len(signal)):
    if signal.iloc[i,1]<signal.iloc[i,2]:
      signal.iloc[i,0]=1.25*signal.iloc[i,0]
  return pd.DataFrame(signal.iloc[:,0])

def signal_boost(signal,vix):
  signal=pd.concat([signal,vix],axis=1)
  signal=signal.dropna()
  for i in range(len(signal)):
    if signal.iloc[i,1]>signal.iloc[i,2]:
      signal.iloc[i,0]=1.25*signal.iloc[i,0]
  return pd.DataFrame(signal.iloc[:,0])

def response_func(x):
  res_sig=x/(np.sqrt(1+x**2)+0.2)
  return res_sig

signals={}

import warnings


# Suppress FutureWarning messages
warnings.filterwarnings('ignore')

data_resampled_agri={}
data_agri={}
portfolio_df=pd.DataFrame()
fp1=pd.DataFrame()
list_vol=[]

for ticker in agri:
  #data consolidation
  data_agri[ticker]=pd.DataFrame(agri_p.loc[:,ticker])
  data_resampled_agri[ticker] = data_agri[ticker]
  data_resampled_agri[ticker][f'Daily Returns_lag{1}']=data_resampled_agri[ticker][ticker].shift(1)
  data_resampled_agri[ticker][f'Daily Returns_lag{20}']=(data_resampled_agri[ticker][f'Daily Returns_lag{1}']).rolling(window=20).mean()
  data_resampled_agri[ticker][f'Vol']=calc_vol(data_resampled_agri[ticker][f'Daily Returns_lag{1}'])['Vol']

  data_resampled_agri[ticker][f'Daily_signal_lag{20}']=(data_resampled_agri[ticker][f'Daily Returns_lag{20}']/(data_resampled_agri[ticker][f'Vol']))*np.sqrt(20)
  data_resampled_agri[ticker][f'Daily_signal_lag_norm{20}'] = np.clip(data_resampled_agri[ticker][f'Daily_signal_lag{20}'], -2, 2)
  #Gearing for the short term trend
  data_resampled_agri[ticker][f'gearing_20']=0.08/(np.sqrt(252)*data_resampled_agri[ticker][f'Vol'])

  #Gearing for the combined signal
  data_resampled_agri[ticker][f'gearing'] = 0.3/(np.sqrt(252)*data_resampled_agri[ticker][f'Vol'])

  #Gearing up the short term signal
  data_resampled_agri[ticker][f'Daily_signal_lag_norm{20}']=data_resampled_agri[ticker][f'Daily_signal_lag_norm{20}']*data_resampled_agri[ticker][f'gearing_20']

  for i in lags1:
    data_resampled_agri[ticker][f'Daily Returns_lag{i}']=(data_resampled_agri[ticker][f'Daily Returns_lag{1}']).rolling(window=i).mean()
  for i in lags2:
    data_resampled_agri[ticker][f'Daily Returns_lag{i}']=(data_resampled_agri[ticker][f'Daily Returns_lag{1}']).rolling(window=i).mean()
  data_resampled_agri[ticker]=data_resampled_agri[ticker].dropna()
  #Calculating Signals
  for i in lags1:
    data_resampled_agri[ticker][f'Daily_signal_lag{i}']=(data_resampled_agri[ticker][f'Daily Returns_lag{i}']/(data_resampled_agri[ticker][f'Vol']))*np.sqrt(i)
    data_resampled_agri[ticker][f'Daily_signal_lag_norm{i}'] = np.clip(data_resampled_agri[ticker][f'Daily_signal_lag{i}'], -2, 2)
  for i in lags2:
    data_resampled_agri[ticker][f'Daily_signal_lag{i}']=(data_resampled_agri[ticker][f'Daily Returns_lag{i}']/(data_resampled_agri[ticker][f'Vol']))*np.sqrt(i)
    data_resampled_agri[ticker][f'Daily_signal_lag_norm{i}'] = np.clip(data_resampled_agri[ticker][f'Daily_signal_lag{i}'], -2, 2)


  #Combining the signal
  cs1=pd.DataFrame(data_resampled_agri[ticker][f'Daily_signal_lag_norm{lags1[0]}']*optimal_weights1[0]+data_resampled_agri[ticker][f'Daily_signal_lag_norm{lags1[1]}']*optimal_weights1[1]+data_resampled_agri[ticker][f'Daily_signal_lag_norm{lags1[2]}']*optimal_weights1[2]+data_resampled_agri[ticker][f'Daily_signal_lag_norm{lags1[3]}']*optimal_weights1[3]+data_resampled_agri[ticker][f'Daily_signal_lag_norm{lags1[4]}']*optimal_weights1[4],columns=['Final Signal_L'])
  cs2=pd.DataFrame(data_resampled_agri[ticker][f'Daily_signal_lag_norm{lags2[0]}']*optimal_weights2[0]+data_resampled_agri[ticker][f'Daily_signal_lag_norm{lags2[1]}']*optimal_weights2[1]+data_resampled_agri[ticker][f'Daily_signal_lag_norm{lags2[2]}']*optimal_weights2[2]+data_resampled_agri[ticker][f'Daily_signal_lag_norm{lags2[3]}']*optimal_weights2[3]+data_resampled_agri[ticker][f'Daily_signal_lag_norm{lags2[4]}']*optimal_weights2[4],columns=['Final Signal_S'])

  cs1=signal_boost(cs1,vix_f)
  cs2=signal_boost(cs2,vix_f)

  data_resampled_agri[ticker]=pd.concat([data_resampled_agri[ticker],cs1],axis=1)
  data_resampled_agri[ticker]=pd.concat([data_resampled_agri[ticker],cs2],axis=1)
  #Gearing up the final signal

for ticker in agri:
  signals[ticker]=pd.DataFrame(data_resampled_agri[ticker][['Final Signal_L','Final Signal_S',f'{ticker}']])
  signals[ticker]['State']=[0]*len(signals[ticker])
  signals[ticker]['Final Signal']=[0]*len(signals[ticker])

  signals[ticker]['P(Bu)']=[0]*len(signals[ticker])
  signals[ticker]['P(Be)']=[0]*len(signals[ticker])
  signals[ticker]['P(Bu|Be)']=[0]*len(signals[ticker])

  #Calcualting returns squared
  signals[ticker][f'{ticker}_R2']=signals[ticker][f'{ticker}']**2

  signals[ticker]['R2|Bu or Be']=[0]*len(signals[ticker])
  signals[ticker]['R2|Co']=[0]*len(signals[ticker])
  signals[ticker]['R2|Re']=[0]*len(signals[ticker])

  signals[ticker]['R|Co']=[0]*len(signals[ticker])
  signals[ticker]['R|Re']=[0]*len(signals[ticker])
  signals[ticker]['R|Bu']=[0]*len(signals[ticker])
  signals[ticker]['R|Be']=[0]*len(signals[ticker])
  for i in signals[ticker].index:
    if(np.sign(signals[ticker].loc[i,'Final Signal_L'])==np.sign(signals[ticker].loc[i,'Final Signal_S']))
    &(np.sign(signals[ticker].loc[i,'Final Signal_L'])>=0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])>0):
      signals[ticker].loc[i,'State']='Bull'
      signals[ticker].loc[i,'P(Bu)']=1
      signals[ticker].loc[i,'P(Bu|Be)']=1
      signals[ticker].loc[i,'R2|Bu or Be']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Bu']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])==np.sign(signals[ticker].loc[i,'Final Signal_S']))
    &(np.sign(signals[ticker].loc[i,'Final Signal_L'])<0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])<0):
      signals[ticker].loc[i,'State']='Bear'
      signals[ticker].loc[i,'P(Be)']=1
      signals[ticker].loc[i,'P(Bu|Be)']=1
      signals[ticker].loc[i,'R2|Bu or Be']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Be']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])!=np.sign(signals[ticker].loc[i,'Final Signal_S']))
    &(np.sign(signals[ticker].loc[i,'Final Signal_L'])>0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])<0):
      signals[ticker].loc[i,'State']='Correction'
      signals[ticker].loc[i,'R2|Co']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Co']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])!=np.sign(signals[ticker].loc[i,'Final Signal_S']))
    &(np.sign(signals[ticker].loc[i,'Final Signal_L'])<0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])>=0):
      signals[ticker].loc[i,'State']='Rebound'
      signals[ticker].loc[i,'R2|Re']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Re']=signals[ticker].loc[i,f'{ticker}']

  signals[ticker]['R|Co']=signals[ticker]['R|Co'].rolling(window=252).mean().shift(1)
  signals[ticker]['R|Re']=signals[ticker]['R|Re'].rolling(window=252).mean().shift(1)
  signals[ticker]['R|Bu']=signals[ticker]['R|Bu'].rolling(window=252).mean().shift(1)
  signals[ticker]['R|Bu']=signals[ticker]['R|Bu'].rolling(window=252).mean().shift(1)

  signals[ticker]['R2|Bu or Be']=signals[ticker]['R2|Bu or Be'].rolling(window=252).mean().shift(1)
  signals[ticker]['R2|Co']=signals[ticker]['R2|Co'].rolling(window=252).mean().shift(1)
  signals[ticker]['R2|Re']=signals[ticker]['R2|Re'].rolling(window=252).mean().shift(1)

  signals[ticker]['P(Bu)']=signals[ticker]['P(Bu)'].rolling(window=252).mean().shift(1)
  signals[ticker]['P(Be)']=signals[ticker]['P(Be)'].rolling(window=252).mean().shift(1)
  signals[ticker]['P(Bu|Be)']=signals[ticker]['P(Bu|Be)'].rolling(window=252).mean().shift(1)

  signals[ticker]=signals[ticker].dropna()
  signals[ticker]['a_Co']=0.5*(1-(((signals[ticker]['R2|Bu or Be']*signals[ticker]['P(Bu|Be)'])
  /(signals[ticker]['R|Bu']*signals[ticker]['P(Bu)']-signals[ticker]['R|Be']*signals[ticker]['P(Be)']))*(signals[ticker]['R|Co']
  /signals[ticker]['R2|Co'])))
  signals[ticker]['a_Re']=0.5*(1+(((signals[ticker]['R2|Bu or Be']*signals[ticker]['P(Bu|Be)'])
  /(signals[ticker]['R|Bu']*signals[ticker]['P(Bu)']-signals[ticker]['R|Be']*signals[ticker]['P(Be)']))*(signals[ticker]['R|Re']
                                                                                                         /signals[ticker]['R2|Re'])))
  signals[ticker]['a_Co']=np.clip(signals[ticker]['a_Co'],0,1)
  signals[ticker]['a_Re']=np.clip(signals[ticker]['a_Re'],0,1)
  for i in signals[ticker].index:
    if signals[ticker].loc[i,'State']=='Rebound':
      signals[ticker].loc[i,'Final Signal']=(1-signals[ticker].loc[i,'a_Re'])*signals[ticker].loc[i,'Final Signal_L']*(-1)
      +signals[ticker].loc[i,'a_Re']*signals[ticker].loc[i,'Final Signal_S']
    #elif signals[ticker].loc[i,'State']=='Correction':
       signals[ticker].loc[i,'Final Signal']=(1-signals[ticker].loc[i,'a_Co'])*signals[ticker].loc[i,'Final Signal_L']
       -signals[ticker].loc[i,'a_Co']*signals[ticker].loc[i,'Final Signal_S']
    else:
      signals[ticker].loc[i,'Final Signal']=(signals[ticker].loc[i,'Final Signal_L']+signals[ticker].loc[i,'Final Signal_S'])/2
   #Smoothing the signal
  signals[ticker]['Final Signal_L']=signals[ticker]['Final Signal_L'].ewm(span=12).mean()
  signals[ticker]['Final Signal']=signals[ticker]['Final Signal'].ewm(span=12).mean()
  #Applying response function
  signals[ticker]['Final Signal_L']=response_func(signals[ticker]['Final Signal_L'])
  signals[ticker]['Final Signal']=response_func(signals[ticker]['Final Signal'])

plt.figure(figsize=(25,8))
plt.plot(signals['FC1 Comdty'].loc[signals['FC1 Comdty'].index.year<=2010,'Final Signal'])
plt.plot(signals['FC1 Comdty'].loc[signals['FC1 Comdty'].index.year<=2010,'Final Signal_L'])

for ticker in agri:
  plt.figure(figsize=(25,8))
  plt.plot(np.cumprod(1+signals[ticker]['Final Signal']*signals[ticker][ticker]*data_resampled_agri[ticker]['gearing'])-1,label='Adjusted')
  plt.plot(np.cumprod(1+signals[ticker]['Final Signal_L']*signals[ticker][ticker]*data_resampled_agri[ticker]['gearing'])-1,label='Normal')
  plt.title(f'{ticker}')
  plt.legend()

signals[ticker]

def calculate_rolling_probabilities(df, window_size):
    # Creating a dataframe to store results
    result = pd.DataFrame(index=df.index)

    # Calculating rolling probabilities
    for state in ['bull', 'bear', 'bull_or_bear']:
        state_mask = df['State'].isin([state, 'bull', 'bear']) if state == 'bull_or_bear' else df['State'] == state
        result[f'Rolling_Prob_{state}'] = (
            df.groupby(state_mask.cumsum())['State']
            .apply(lambda x: x.eq(state).rolling(window=window_size).mean())
            .reset_index(drop=True)
        )

    # Calculating rolling returns for bull and bear states
    for state in ['bull', 'bear']:
        state_mask = df['State'] == state
        result[f'Rolling_Return_{state}'] = (
            df.loc[state_mask, 'Returns']
            .rolling(window=window_size)
            .sum()
            .reset_index(drop=True)
        )

    return result

# Calculate rolling probabilities and returns with a window size of 630 days
window_size = 630
rolling_results = calculate_rolling_probabilities(df, window_size)
print(rolling_results)

plt.figure(figsize=(25,8))
plt.plot(signals[ticker]["Final Signal"].iloc[1000:2000])
plt.plot(signals[ticker]["Final Signal_L"].iloc[1000:2000])

color_dict = { 'Bull':'green', 'Bear':'red', 'Correction':'yellow', 'Rebound':'orange'}
plt.figure(figsize=(25,8))
plt.scatter(signals['W 1 Comdty']['Final Signal_L'],signals['W 1 Comdty']['Final Signal_S'],color=[ color_dict[i] for i in signals['W 1 Comdty']['State'] ])
plt.xlabel('Long')
plt.ylabel('Short')

signals['C 1 Comdty']['State'].value_counts()

for ticker in agri:
  x_agri=pd.DataFrame(signals[ticker].loc[signals[ticker].State=='Bear']).index_agri
  x_agri1=data_resampled_agri[ticker].loc[x_agri,ticker]*data_resampled_agri[ticker].loc[x_agri,'gearing']*data_resampled_agri[ticker].loc[x_agri,'Final Signal_S']
  plt.figure(figsize=(25,8))
  a=np.cumprod(1+data_resampled_agri[ticker].loc[x_agri,ticker]*data_resampled_agri[ticker].loc[x_agri,'gearing']*data_resampled_agri[ticker].loc[x_agri,'Final Signal_S'])[-1]
  b=np.cumprod(1+data_resampled_agri[ticker].loc[x_agri,ticker]*data_resampled_agri[ticker].loc[x_agri,'gearing']*data_resampled_agri[ticker].loc[x_agri,'Final Signal_L'])[-1]
  print(ticker,a-b)
  print(a)
  print(b)
  plt.figure(figsize=(25,8))
  plt.scatter(x_agri,x_agri1)
  plt.title(f'{ticker}')

data_resampled_met={}
data_met={}
portfolio_df=pd.DataFrame()
fp1=pd.DataFrame()
list_vol=[]

for ticker in met:
  #data consolidation
  data_met[ticker]=pd.DataFrame(met_p.loc[:,ticker])
  data_resampled_met[ticker] = data_met[ticker]
  data_resampled_met[ticker][f'Daily Returns_lag{1}']=data_resampled_met[ticker][ticker].shift(1)
  data_resampled_met[ticker][f'Daily Returns_lag{20}']=(data_resampled_met[ticker][f'Daily Returns_lag{1}']).rolling(window=20).mean()
  data_resampled_met[ticker][f'Vol']=calc_vol(data_resampled_met[ticker][f'Daily Returns_lag{1}'])['Vol']

  data_resampled_met[ticker][f'Daily_signal_lag{20}']=(data_resampled_met[ticker][f'Daily Returns_lag{20}']/(data_resampled_met[ticker][f'Vol']))*np.sqrt(20)
  data_resampled_met[ticker][f'Daily_signal_lag_norm{20}'] = np.clip(data_resampled_met[ticker][f'Daily_signal_lag{20}'], -2, 2)
  #Gearing for the short term trend
  data_resampled_met[ticker][f'gearing_20']=0.08/(np.sqrt(252)*data_resampled_met[ticker][f'Vol'])

  #Gearing for the combined signal
  data_resampled_met[ticker][f'gearing'] = 0.3/(np.sqrt(252)*data_resampled_met[ticker][f'Vol'])

  #Gearing up the short term signal
  data_resampled_met[ticker][f'Daily_signal_lag_norm{20}']=data_resampled_met[ticker][f'Daily_signal_lag_norm{20}']*data_resampled_met[ticker][f'gearing_20']

  for i in lags1:
    data_resampled_met[ticker][f'Daily Returns_lag{i}']=(data_resampled_met[ticker][f'Daily Returns_lag{1}']).rolling(window=i).mean()
  for i in lags2:
    data_resampled_met[ticker][f'Daily Returns_lag{i}']=(data_resampled_met[ticker][f'Daily Returns_lag{1}']).rolling(window=i).mean()
  data_resampled_met[ticker]=data_resampled_met[ticker].dropna()
  #Calculating Signals
  for i in lags1:
    data_resampled_met[ticker][f'Daily_signal_lag{i}']=(data_resampled_met[ticker][f'Daily Returns_lag{i}']/(data_resampled_met[ticker][f'Vol']))*np.sqrt(i)
    data_resampled_met[ticker][f'Daily_signal_lag_norm{i}'] = np.clip(data_resampled_met[ticker][f'Daily_signal_lag{i}'], -2, 2)
  for i in lags2:
    data_resampled_met[ticker][f'Daily_signal_lag{i}']=(data_resampled_met[ticker][f'Daily Returns_lag{i}']/(data_resampled_met[ticker][f'Vol']))*np.sqrt(i)
    data_resampled_met[ticker][f'Daily_signal_lag_norm{i}'] = np.clip(data_resampled_met[ticker][f'Daily_signal_lag{i}'], -2, 2)


  #Combining the signal
  cs1=pd.DataFrame(data_resampled_met[ticker][f'Daily_signal_lag_norm{lags1[0]}']*optimal_weights1[0]+data_resampled_met[ticker][f'Daily_signal_lag_norm{lags1[1]}']*optimal_weights1[1]+data_resampled_met[ticker][f'Daily_signal_lag_norm{lags1[2]}']*optimal_weights1[2]+data_resampled_met[ticker][f'Daily_signal_lag_norm{lags1[3]}']*optimal_weights1[3]+data_resampled_met[ticker][f'Daily_signal_lag_norm{lags1[4]}']*optimal_weights1[4],columns=['Final Signal_L'])
  cs2=pd.DataFrame(data_resampled_met[ticker][f'Daily_signal_lag_norm{lags2[0]}']*optimal_weights2[0]+data_resampled_met[ticker][f'Daily_signal_lag_norm{lags2[1]}']*optimal_weights2[1]+data_resampled_met[ticker][f'Daily_signal_lag_norm{lags2[2]}']*optimal_weights2[2]+data_resampled_met[ticker][f'Daily_signal_lag_norm{lags2[3]}']*optimal_weights2[3]+data_resampled_met[ticker][f'Daily_signal_lag_norm{lags2[4]}']*optimal_weights2[4],columns=['Final Signal_S'])

  cs1=signal_boost(cs1,vix_f)
  cs2=signal_boost(cs2,vix_f)

  data_resampled_met[ticker]=pd.concat([data_resampled_met[ticker],cs1],axis=1)
  data_resampled_met[ticker]=pd.concat([data_resampled_met[ticker],cs2],axis=1)

for ticker in met:
  signals[ticker]=pd.DataFrame(data_resampled_met[ticker][['Final Signal_L','Final Signal_S',f'{ticker}']])
  signals[ticker]['State']=[0]*len(signals[ticker])
  signals[ticker]['Final Signal']=[0]*len(signals[ticker])

  signals[ticker]['P(Bu)']=[0]*len(signals[ticker])
  signals[ticker]['P(Be)']=[0]*len(signals[ticker])
  signals[ticker]['P(Bu|Be)']=[0]*len(signals[ticker])

  #Calcualting returns squared
  signals[ticker][f'{ticker}_R2']=signals[ticker][f'{ticker}']**2

  signals[ticker]['R2|Bu or Be']=[0]*len(signals[ticker])
  signals[ticker]['R2|Co']=[0]*len(signals[ticker])
  signals[ticker]['R2|Re']=[0]*len(signals[ticker])

  signals[ticker]['R|Co']=[0]*len(signals[ticker])
  signals[ticker]['R|Re']=[0]*len(signals[ticker])
  signals[ticker]['R|Bu']=[0]*len(signals[ticker])
  signals[ticker]['R|Be']=[0]*len(signals[ticker])
  for i in signals[ticker].index:
    if(np.sign(signals[ticker].loc[i,'Final Signal_L'])==np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])>=0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])>0):
      signals[ticker].loc[i,'State']='Bull'
      signals[ticker].loc[i,'P(Bu)']=1
      signals[ticker].loc[i,'P(Bu|Be)']=1
      signals[ticker].loc[i,'R2|Bu or Be']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Bu']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])==np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])<0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])<0):
      signals[ticker].loc[i,'State']='Bear'
      signals[ticker].loc[i,'P(Be)']=1
      signals[ticker].loc[i,'P(Bu|Be)']=1
      signals[ticker].loc[i,'R2|Bu or Be']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Be']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])!=np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])>0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])<0):
      signals[ticker].loc[i,'State']='Correction'
      signals[ticker].loc[i,'R2|Co']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Co']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])!=np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])<0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])>=0):
      signals[ticker].loc[i,'State']='Rebound'
      signals[ticker].loc[i,'R2|Re']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Re']=signals[ticker].loc[i,f'{ticker}']

  signals[ticker]['R|Co']=signals[ticker]['R|Co'].rolling(window=252).mean().shift(1)
  signals[ticker]['R|Re']=signals[ticker]['R|Re'].rolling(window=252).mean().shift(1)
  signals[ticker]['R|Bu']=signals[ticker]['R|Bu'].rolling(window=252).mean().shift(1)
  signals[ticker]['R|Bu']=signals[ticker]['R|Bu'].rolling(window=252).mean().shift(1)

  signals[ticker]['R2|Bu or Be']=signals[ticker]['R2|Bu or Be'].rolling(window=252).mean().shift(1)
  signals[ticker]['R2|Co']=signals[ticker]['R2|Co'].rolling(window=252).mean().shift(1)
  signals[ticker]['R2|Re']=signals[ticker]['R2|Re'].rolling(window=252).mean().shift(1)

  signals[ticker]['P(Bu)']=signals[ticker]['P(Bu)'].rolling(window=252).mean().shift(1)
  signals[ticker]['P(Be)']=signals[ticker]['P(Be)'].rolling(window=252).mean().shift(1)
  signals[ticker]['P(Bu|Be)']=signals[ticker]['P(Bu|Be)'].rolling(window=252).mean().shift(1)

  signals[ticker]=signals[ticker].dropna()
  signals[ticker]['a_Co']=0.5*(1-(((signals[ticker]['R2|Bu or Be']*signals[ticker]['P(Bu|Be)'])/(signals[ticker]['R|Bu']*signals[ticker]['P(Bu)']-signals[ticker]['R|Be']*signals[ticker]['P(Be)']))*(signals[ticker]['R|Co']/signals[ticker]['R2|Co'])))
  signals[ticker]['a_Re']=0.5*(1+(((signals[ticker]['R2|Bu or Be']*signals[ticker]['P(Bu|Be)'])/(signals[ticker]['R|Bu']*signals[ticker]['P(Bu)']-signals[ticker]['R|Be']*signals[ticker]['P(Be)']))*(signals[ticker]['R|Re']/signals[ticker]['R2|Re'])))
  signals[ticker]['a_Co']=np.clip(signals[ticker]['a_Co'],0,1)
  signals[ticker]['a_Re']=np.clip(signals[ticker]['a_Re'],0,1)
  for i in signals[ticker].index:
    if signals[ticker].loc[i,'State']=='Rebound':
      signals[ticker].loc[i,'Final Signal']=(1-signals[ticker].loc[i,'a_Re'])*signals[ticker].loc[i,'Final Signal_L']*(-1)+signals[ticker].loc[i,'a_Re']*signals[ticker].loc[i,'Final Signal_S']
    elif signals[ticker].loc[i,'State']=='Correction':
      signals[ticker].loc[i,'Final Signal']=(1-signals[ticker].loc[i,'a_Co'])*signals[ticker].loc[i,'Final Signal_L']-signals[ticker].loc[i,'a_Co']*signals[ticker].loc[i,'Final Signal_S']
    else:
      signals[ticker].loc[i,'Final Signal']=(signals[ticker].loc[i,'Final Signal_L']+signals[ticker].loc[i,'Final Signal_S'])/2
   #Smoothing the signal
  signals[ticker]['Final Signal_L']=signals[ticker]['Final Signal_L'].ewm(span=12).mean()
  signals[ticker]['Final Signal']=signals[ticker]['Final Signal'].ewm(span=12).mean()
  #Applying response function
  signals[ticker]['Final Signal_L']=response_func(signals[ticker]['Final Signal_L'])
  signals[ticker]['Final Signal']=response_func(signals[ticker]['Final Signal'])

for ticker in met:
  plt.figure(figsize=(25,8))
  print((signals[ticker]['Final Signal']*data_resampled_met[ticker]['gearing']*data_resampled_met[ticker][ticker]).std()*np.sqrt(252))
  print((signals[ticker]['Final Signal_L']*data_resampled_met[ticker]['gearing']*data_resampled_met[ticker][ticker]).std()*np.sqrt(252))
  plt.plot(np.cumprod(1+signals[ticker]['Final Signal']*data_resampled_met[ticker]['gearing']*data_resampled_met[ticker][ticker])-1,label='Corrected')
  plt.plot(np.cumprod(1+signals[ticker]['Final Signal_L']*data_resampled_met[ticker]['gearing']*data_resampled_met[ticker][ticker])-1,label='Previous')
  plt.title(f'{ticker}')
  plt.legend()

for ticker in met:
  plt.figure(figsize=(25,8))
  plt.plot(signals[ticker]['Final Signal']*data_resampled_met[ticker]['gearing'],label='Corrected')
  plt.plot(signals[ticker]['Final Signal_L']*data_resampled_met[ticker]['gearing'],label='Previous')
  plt.title(f'{ticker}')
  plt.legend()



color_dict = { 'Bull':'green', 'Bear':'red', 'Correction':'yellow', 'Rebound':'orange'}
for ticker in met:
  plt.figure(figsize=(25,8))
  plt.scatter(signals[ticker]['Final Signal_L'],signals[ticker]['Final Signal_S'],color=[ color_dict[i] for i in signals[ticker]['State'] ])
  plt.xlabel('Long')
  plt.ylabel('Short')
  plt.title(f'{ticker}')

for ticker in met:
  x_met=pd.DataFrame(signals[ticker].loc[signals[ticker].State=='Rebound']).index
  x_met1=data_resampled_met[ticker].loc[x_met,ticker]*data_resampled_met[ticker].loc[x_met,'gearing']*data_resampled_met[ticker].loc[x_met,'Final Signal_S']
  plt.figure(figsize=(25,8))
  a=np.cumprod(1+data_resampled_met[ticker].loc[x_met,ticker]*data_resampled_met[ticker].loc[x_met,'gearing']*data_resampled_met[ticker].loc[x_met,'Final Signal_S'])[-1]-1
  b=np.cumprod(1+data_resampled_met[ticker].loc[x_met,ticker]*data_resampled_met[ticker].loc[x_met,'gearing']*data_resampled_met[ticker].loc[x_met,'Final Signal_L'])[-1]-1
  print(ticker,a-b)
  print(a)
  print(b)
  plt.figure(figsize=(25,8))
  plt.scatter(x_met,x_met1)
  plt.title(f'{ticker}')

data_resampled_ener={}
data_ener={}
portfolio_df=pd.DataFrame()
fp1=pd.DataFrame()
list_vol=[]

for ticker in ener:
  #data consolidation
  data_ener[ticker]=pd.DataFrame(ener_p.loc[:,ticker])
  data_resampled_ener[ticker] = data_ener[ticker]
  data_resampled_ener[ticker][f'Daily Returns_lag{1}']=data_resampled_ener[ticker][ticker].shift(1)
  data_resampled_ener[ticker][f'Daily Returns_lag{20}']=(data_resampled_ener[ticker][f'Daily Returns_lag{1}']).rolling(window=20).mean()
  data_resampled_ener[ticker][f'Vol']=calc_vol(data_resampled_ener[ticker][f'Daily Returns_lag{1}'])['Vol']

  data_resampled_ener[ticker][f'Daily_signal_lag{20}']=(data_resampled_ener[ticker][f'Daily Returns_lag{20}']/(data_resampled_ener[ticker][f'Vol']))*np.sqrt(20)
  data_resampled_ener[ticker][f'Daily_signal_lag_norm{20}'] = np.clip(data_resampled_ener[ticker][f'Daily_signal_lag{20}'], -2, 2)
  #Gearing for the short term trend
  data_resampled_ener[ticker][f'gearing_20']=0.08/(np.sqrt(252)*data_resampled_ener[ticker][f'Vol'])

  #Gearing for the combined signal
  data_resampled_ener[ticker][f'gearing'] = 0.3/(np.sqrt(252)*data_resampled_ener[ticker][f'Vol'])

  #Gearing up the short term signal
  data_resampled_ener[ticker][f'Daily_signal_lag_norm{20}']=data_resampled_ener[ticker][f'Daily_signal_lag_norm{20}']*data_resampled_ener[ticker][f'gearing_20']

  for i in lags1:
    data_resampled_ener[ticker][f'Daily Returns_lag{i}']=(data_resampled_ener[ticker][f'Daily Returns_lag{1}']).rolling(window=i).mean()
  for i in lags2:
    data_resampled_ener[ticker][f'Daily Returns_lag{i}']=(data_resampled_ener[ticker][f'Daily Returns_lag{1}']).rolling(window=i).mean()
  data_resampled_ener[ticker]=data_resampled_ener[ticker].dropna()
  #Calculating Signals
  for i in lags1:
    data_resampled_ener[ticker][f'Daily_signal_lag{i}']=(data_resampled_ener[ticker][f'Daily Returns_lag{i}']/(data_resampled_ener[ticker][f'Vol']))*np.sqrt(i)
    data_resampled_ener[ticker][f'Daily_signal_lag_norm{i}'] = np.clip(data_resampled_ener[ticker][f'Daily_signal_lag{i}'], -2, 2)
  for i in lags2:
    data_resampled_ener[ticker][f'Daily_signal_lag{i}']=(data_resampled_ener[ticker][f'Daily Returns_lag{i}']/(data_resampled_ener[ticker][f'Vol']))*np.sqrt(i)
    data_resampled_ener[ticker][f'Daily_signal_lag_norm{i}'] = np.clip(data_resampled_ener[ticker][f'Daily_signal_lag{i}'], -2, 2)


  #Combining the signal
  cs1=pd.DataFrame(data_resampled_ener[ticker][f'Daily_signal_lag_norm{lags1[0]}']*optimal_weights1[0]+data_resampled_ener[ticker][f'Daily_signal_lag_norm{lags1[1]}']*optimal_weights1[1]+data_resampled_ener[ticker][f'Daily_signal_lag_norm{lags1[2]}']*optimal_weights1[2]+data_resampled_ener[ticker][f'Daily_signal_lag_norm{lags1[3]}']*optimal_weights1[3]+data_resampled_ener[ticker][f'Daily_signal_lag_norm{lags1[4]}']*optimal_weights1[4],columns=['Final Signal_L'])
  cs2=pd.DataFrame(data_resampled_ener[ticker][f'Daily_signal_lag_norm{lags2[0]}']*optimal_weights2[0]+data_resampled_ener[ticker][f'Daily_signal_lag_norm{lags2[1]}']*optimal_weights2[1]+data_resampled_ener[ticker][f'Daily_signal_lag_norm{lags2[2]}']*optimal_weights2[2]+data_resampled_ener[ticker][f'Daily_signal_lag_norm{lags2[3]}']*optimal_weights2[3]+data_resampled_ener[ticker][f'Daily_signal_lag_norm{lags2[4]}']*optimal_weights2[4],columns=['Final Signal_S'])

  cs1=signal_boost(cs1,vix_f)
  cs2=signal_boost(cs2,vix_f)

  data_resampled_ener[ticker]=pd.concat([data_resampled_ener[ticker],cs1],axis=1)
  data_resampled_ener[ticker]=pd.concat([data_resampled_ener[ticker],cs2],axis=1)

for ticker in ener:
  signals[ticker]=pd.DataFrame(data_resampled_ener[ticker][['Final Signal_L','Final Signal_S',f'{ticker}']])
  signals[ticker]['State']=[0]*len(signals[ticker])
  signals[ticker]['Final Signal']=[0]*len(signals[ticker])

  signals[ticker]['P(Bu)']=[0]*len(signals[ticker])
  signals[ticker]['P(Be)']=[0]*len(signals[ticker])
  signals[ticker]['P(Bu|Be)']=[0]*len(signals[ticker])

  #Calcualting returns squared
  signals[ticker][f'{ticker}_R2']=signals[ticker][f'{ticker}']**2

  signals[ticker]['R2|Bu or Be']=[0]*len(signals[ticker])
  signals[ticker]['R2|Co']=[0]*len(signals[ticker])
  signals[ticker]['R2|Re']=[0]*len(signals[ticker])

  signals[ticker]['R|Co']=[0]*len(signals[ticker])
  signals[ticker]['R|Re']=[0]*len(signals[ticker])
  signals[ticker]['R|Bu']=[0]*len(signals[ticker])
  signals[ticker]['R|Be']=[0]*len(signals[ticker])
  for i in signals[ticker].index:
    if(np.sign(signals[ticker].loc[i,'Final Signal_L'])==np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])>=0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])>0):
      signals[ticker].loc[i,'State']='Bull'
      signals[ticker].loc[i,'P(Bu)']=1
      signals[ticker].loc[i,'P(Bu|Be)']=1
      signals[ticker].loc[i,'R2|Bu or Be']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Bu']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])==np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])<0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])<0):
      signals[ticker].loc[i,'State']='Bear'
      signals[ticker].loc[i,'P(Be)']=1
      signals[ticker].loc[i,'P(Bu|Be)']=1
      signals[ticker].loc[i,'R2|Bu or Be']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Be']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])!=np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])>0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])<0):
      signals[ticker].loc[i,'State']='Correction'
      signals[ticker].loc[i,'R2|Co']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Co']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])!=np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])<0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])>=0):
      signals[ticker].loc[i,'State']='Rebound'
      signals[ticker].loc[i,'R2|Re']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Re']=signals[ticker].loc[i,f'{ticker}']

  signals[ticker]['R|Co']=signals[ticker]['R|Co'].rolling(window=630).mean().shift(1)
  signals[ticker]['R|Re']=signals[ticker]['R|Re'].rolling(window=630).mean().shift(1)
  signals[ticker]['R|Bu']=signals[ticker]['R|Bu'].rolling(window=630).mean().shift(1)
  signals[ticker]['R|Bu']=signals[ticker]['R|Bu'].rolling(window=630).mean().shift(1)

  signals[ticker]['R2|Bu or Be']=signals[ticker]['R2|Bu or Be'].rolling(window=630).mean().shift(1)
  signals[ticker]['R2|Co']=signals[ticker]['R2|Co'].rolling(window=630).mean().shift(1)
  signals[ticker]['R2|Re']=signals[ticker]['R2|Re'].rolling(window=630).mean().shift(1)

  signals[ticker]['P(Bu)']=signals[ticker]['P(Bu)'].rolling(window=630).mean().shift(1)
  signals[ticker]['P(Be)']=signals[ticker]['P(Be)'].rolling(window=630).mean().shift(1)
  signals[ticker]['P(Bu|Be)']=signals[ticker]['P(Bu|Be)'].rolling(window=630).mean().shift(1)

  signals[ticker]=signals[ticker].dropna()
  signals[ticker]['a_Co']=0.5*(1-(((signals[ticker]['R2|Bu or Be']*signals[ticker]['P(Bu|Be)'])/(signals[ticker]['R|Bu']*signals[ticker]['P(Bu)']-signals[ticker]['R|Be']*signals[ticker]['P(Be)']))*(signals[ticker]['R|Co']/signals[ticker]['R2|Co'])))
  signals[ticker]['a_Re']=0.5*(1+(((signals[ticker]['R2|Bu or Be']*signals[ticker]['P(Bu|Be)'])/(signals[ticker]['R|Bu']*signals[ticker]['P(Bu)']-signals[ticker]['R|Be']*signals[ticker]['P(Be)']))*(signals[ticker]['R|Re']/signals[ticker]['R2|Re'])))
  signals[ticker]['a_Co']=np.clip(signals[ticker]['a_Co'],0,1)
  signals[ticker]['a_Re']=np.clip(signals[ticker]['a_Re'],0,1)
  for i in signals[ticker].index:
    if signals[ticker].loc[i,'State']=='Rebound':
      signals[ticker].loc[i,'Final Signal']=(1-signals[ticker].loc[i,'a_Re'])*signals[ticker].loc[i,'Final Signal_L']*(-1)+signals[ticker].loc[i,'a_Re']*signals[ticker].loc[i,'Final Signal_S']
    if signals[ticker].loc[i,'State']=='Correction':
      signals[ticker].loc[i,'Final Signal']=(1-signals[ticker].loc[i,'a_Co'])*signals[ticker].loc[i,'Final Signal_L']-signals[ticker].loc[i,'a_Co']*signals[ticker].loc[i,'Final Signal_S']
    else:
      signals[ticker].loc[i,'Final Signal']=signals[ticker].loc[i,'Final Signal_L']
   #Smoothing the signal
  signals[ticker]['Final Signal_L']=signals[ticker]['Final Signal_L'].ewm(span=12).mean()
  signals[ticker]['Final Signal']=signals[ticker]['Final Signal'].ewm(span=12).mean()
  #Applying response function
  signals[ticker]['Final Signal_L']=response_func(signals[ticker]['Final Signal_L'])
  signals[ticker]['Final Signal']=response_func(signals[ticker]['Final Signal'])

for ticker in ener:
  plt.figure(figsize=(25,8))
  plt.plot(np.cumprod(1+signals[ticker]['Final Signal']*data_resampled_ener[ticker]['gearing']*data_resampled_ener[ticker][ticker])-1,label='Corrected')
  plt.plot(np.cumprod(1+signals[ticker]['Final Signal_L']*data_resampled_ener[ticker]['gearing']*data_resampled_ener[ticker][ticker])-1,label='Previous')
  plt.title(f'{ticker}')
  plt.legend()

for ticker in ener:
  plt.figure(figsize=(25,8))
  plt.plot(signals[ticker]['Final Signal'],label='Corrected')
  plt.plot(signals[ticker]['Final Signal_L'],label='Previous')
  plt.title(f'{ticker}')
  plt.legend()

color_dict = { 'Bull':'green', 'Bear':'red', 'Correction':'yellow', 'Rebound':'orange'}
for ticker in ener:
  plt.figure(figsize=(25,8))
  plt.scatter(signals[ticker]['Final Signal_L'],signals[ticker]['Final Signal_S'],color=[ color_dict[i] for i in signals[ticker]['State'] ])
  plt.xlabel('Long')
  plt.ylabel('Short')
  plt.title(f'{ticker}')

for ticker in ener:
  x_ener=pd.DataFrame(signals[ticker].loc[signals[ticker].State=='Bull']).index
  x_ener1=data_resampled_ener[ticker].loc[x_ener,ticker]*data_resampled_ener[ticker].loc[x_ener,'gearing']*data_resampled_ener[ticker].loc[x_ener,'Final Signal_S']
  plt.figure(figsize=(25,8))
  a=np.cumprod(1+data_resampled_ener[ticker].loc[x_ener,ticker]*data_resampled_ener[ticker].loc[x_ener,'gearing']*data_resampled_ener[ticker].loc[x_ener,'Final Signal_S'])[-1]-1
  b=np.cumprod(1+data_resampled_ener[ticker].loc[x_ener,ticker]*data_resampled_ener[ticker].loc[x_ener,'gearing']*data_resampled_ener[ticker].loc[x_ener,'Final Signal_L'])[-1]-1
  print(ticker,a-b)
  print(a)
  print(b)
  plt.figure(figsize=(25,8))
  plt.scatter(x_ener,x_ener1)
  plt.title(f'{ticker}')

signals[ticker]

data_resampled_eq={}
data_eq={}
portfolio_df=pd.DataFrame()
fp1=pd.DataFrame()
list_vol=[]

for ticker in eq:
  #data consolidation
  data_eq[ticker]=pd.DataFrame(eq_p.loc[:,ticker])
  data_resampled_eq[ticker] = data_eq[ticker]
  data_resampled_eq[ticker][f'Daily Returns_lag{1}']=data_resampled_eq[ticker][ticker].shift(1)
  data_resampled_eq[ticker][f'Daily Returns_lag{20}']=(data_resampled_eq[ticker][f'Daily Returns_lag{1}']).rolling(window=20).mean()
  data_resampled_eq[ticker][f'Vol']=calc_vol(data_resampled_eq[ticker][f'Daily Returns_lag{1}'])['Vol']

  data_resampled_eq[ticker][f'Daily_signal_lag{20}']=(data_resampled_eq[ticker][f'Daily Returns_lag{20}']/(data_resampled_eq[ticker][f'Vol']))*np.sqrt(20)
  data_resampled_eq[ticker][f'Daily_signal_lag_norm{20}'] = np.clip(data_resampled_eq[ticker][f'Daily_signal_lag{20}'], -2, 2)
  #Gearing for the short term trend
  data_resampled_eq[ticker][f'gearing_20']=0.08/(np.sqrt(252)*data_resampled_eq[ticker][f'Vol'])

  #Gearing for the combined signal
  data_resampled_eq[ticker][f'gearing'] = 0.3/(np.sqrt(252)*data_resampled_eq[ticker][f'Vol'])

  #Gearing up the short term signal
  data_resampled_eq[ticker][f'Daily_signal_lag_norm{20}']=data_resampled_eq[ticker][f'Daily_signal_lag_norm{20}']*data_resampled_eq[ticker][f'gearing_20']

  for i in lags1:
    data_resampled_eq[ticker][f'Daily Returns_lag{i}']=(data_resampled_eq[ticker][f'Daily Returns_lag{1}']).rolling(window=i).mean()
  for i in lags2:
    data_resampled_eq[ticker][f'Daily Returns_lag{i}']=(data_resampled_eq[ticker][f'Daily Returns_lag{1}']).rolling(window=i).mean()
  data_resampled_eq[ticker]=data_resampled_eq[ticker].dropna()
  #Calculating Signals
  for i in lags1:
    data_resampled_eq[ticker][f'Daily_signal_lag{i}']=(data_resampled_eq[ticker][f'Daily Returns_lag{i}']/(data_resampled_eq[ticker][f'Vol']))*np.sqrt(i)
    data_resampled_eq[ticker][f'Daily_signal_lag_norm{i}'] = np.clip(data_resampled_eq[ticker][f'Daily_signal_lag{i}'], -2, 2)
  for i in lags2:
    data_resampled_eq[ticker][f'Daily_signal_lag{i}']=(data_resampled_eq[ticker][f'Daily Returns_lag{i}']/(data_resampled_eq[ticker][f'Vol']))*np.sqrt(i)
    data_resampled_eq[ticker][f'Daily_signal_lag_norm{i}'] = np.clip(data_resampled_eq[ticker][f'Daily_signal_lag{i}'], -2, 2)


  #Combining the signal
  cs1=pd.DataFrame(data_resampled_eq[ticker][f'Daily_signal_lag_norm{lags1[0]}']*optimal_weights1[0]+data_resampled_eq[ticker][f'Daily_signal_lag_norm{lags1[1]}']*optimal_weights1[1]+data_resampled_eq[ticker][f'Daily_signal_lag_norm{lags1[2]}']*optimal_weights1[2]+data_resampled_eq[ticker][f'Daily_signal_lag_norm{lags1[3]}']*optimal_weights1[3]+data_resampled_eq[ticker][f'Daily_signal_lag_norm{lags1[4]}']*optimal_weights1[4],columns=['Final Signal_L'])
  cs2=pd.DataFrame(data_resampled_eq[ticker][f'Daily_signal_lag_norm{lags2[0]}']*optimal_weights2[0]+data_resampled_eq[ticker][f'Daily_signal_lag_norm{lags2[1]}']*optimal_weights2[1]+data_resampled_eq[ticker][f'Daily_signal_lag_norm{lags2[2]}']*optimal_weights2[2]+data_resampled_eq[ticker][f'Daily_signal_lag_norm{lags2[3]}']*optimal_weights2[3]+data_resampled_eq[ticker][f'Daily_signal_lag_norm{lags2[4]}']*optimal_weights2[4],columns=['Final Signal_S'])

  cs1=signal_boost(cs1,vix_f)
  cs2=signal_boost(cs2,vix_f)

  data_resampled_eq[ticker]=pd.concat([data_resampled_eq[ticker],cs1],axis=1)
  data_resampled_eq[ticker]=pd.concat([data_resampled_eq[ticker],cs2],axis=1)

for ticker in eq:
  signals[ticker]=pd.DataFrame(data_resampled_eq[ticker][['Final Signal_L','Final Signal_S',f'{ticker}']])
  signals[ticker]['State']=[0]*len(signals[ticker])
  signals[ticker]['Final Signal']=[0]*len(signals[ticker])

  signals[ticker]['P(Bu)']=[0]*len(signals[ticker])
  signals[ticker]['P(Be)']=[0]*len(signals[ticker])
  signals[ticker]['P(Bu|Be)']=[0]*len(signals[ticker])

  #Calcualting returns squared
  signals[ticker][f'{ticker}_R2']=signals[ticker][f'{ticker}']**2

  signals[ticker]['R2|Bu or Be']=[0]*len(signals[ticker])
  signals[ticker]['R2|Co']=[0]*len(signals[ticker])
  signals[ticker]['R2|Re']=[0]*len(signals[ticker])

  signals[ticker]['R|Co']=[0]*len(signals[ticker])
  signals[ticker]['R|Re']=[0]*len(signals[ticker])
  signals[ticker]['R|Bu']=[0]*len(signals[ticker])
  signals[ticker]['R|Be']=[0]*len(signals[ticker])
  for i in signals[ticker].index:
    if(np.sign(signals[ticker].loc[i,'Final Signal_L'])==np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])>=0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])>0):
      signals[ticker].loc[i,'State']='Bull'
      signals[ticker].loc[i,'P(Bu)']=1
      signals[ticker].loc[i,'P(Bu|Be)']=1
      signals[ticker].loc[i,'R2|Bu or Be']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Bu']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])==np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])<0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])<0):
      signals[ticker].loc[i,'State']='Bear'
      signals[ticker].loc[i,'P(Be)']=1
      signals[ticker].loc[i,'P(Bu|Be)']=1
      signals[ticker].loc[i,'R2|Bu or Be']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Be']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])!=np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])>0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])<0):
      signals[ticker].loc[i,'State']='Correction'
      signals[ticker].loc[i,'R2|Co']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Co']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])!=np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])<0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])>=0):
      signals[ticker].loc[i,'State']='Rebound'
      signals[ticker].loc[i,'R2|Re']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Re']=signals[ticker].loc[i,f'{ticker}']

  signals[ticker]['R|Co']=signals[ticker]['R|Co'].rolling(window=630).mean().shift(1)
  signals[ticker]['R|Re']=signals[ticker]['R|Re'].rolling(window=630).mean().shift(1)
  signals[ticker]['R|Bu']=signals[ticker]['R|Bu'].rolling(window=630).mean().shift(1)
  signals[ticker]['R|Bu']=signals[ticker]['R|Bu'].rolling(window=630).mean().shift(1)

  signals[ticker]['R2|Bu or Be']=signals[ticker]['R2|Bu or Be'].rolling(window=630).mean().shift(1)
  signals[ticker]['R2|Co']=signals[ticker]['R2|Co'].rolling(window=630).mean().shift(1)
  signals[ticker]['R2|Re']=signals[ticker]['R2|Re'].rolling(window=630).mean().shift(1)

  signals[ticker]['P(Bu)']=signals[ticker]['P(Bu)'].rolling(window=630).mean().shift(1)
  signals[ticker]['P(Be)']=signals[ticker]['P(Be)'].rolling(window=630).mean().shift(1)
  signals[ticker]['P(Bu|Be)']=signals[ticker]['P(Bu|Be)'].rolling(window=630).mean().shift(1)

  signals[ticker]=signals[ticker].dropna()
  signals[ticker]['a_Co']=0.5*(1-(((signals[ticker]['R2|Bu or Be']*signals[ticker]['P(Bu|Be)'])/(signals[ticker]['R|Bu']*signals[ticker]['P(Bu)']-signals[ticker]['R|Be']*signals[ticker]['P(Be)']))*(signals[ticker]['R|Co']/signals[ticker]['R2|Co'])))
  signals[ticker]['a_Re']=0.5*(1+(((signals[ticker]['R2|Bu or Be']*signals[ticker]['P(Bu|Be)'])/(signals[ticker]['R|Bu']*signals[ticker]['P(Bu)']-signals[ticker]['R|Be']*signals[ticker]['P(Be)']))*(signals[ticker]['R|Re']/signals[ticker]['R2|Re'])))
  signals[ticker]['a_Co']=np.clip(signals[ticker]['a_Co'],0,1)
  signals[ticker]['a_Re']=np.clip(signals[ticker]['a_Re'],0,1)
  for i in signals[ticker].index:
    if signals[ticker].loc[i,'State']=='Rebound':
      signals[ticker].loc[i,'Final Signal']=(1-signals[ticker].loc[i,'a_Re'])*signals[ticker].loc[i,'Final Signal_L']*(-1)+signals[ticker].loc[i,'a_Re']*signals[ticker].loc[i,'Final Signal_S']
    elif signals[ticker].loc[i,'State']=='Correction':
      signals[ticker].loc[i,'Final Signal']=(1-signals[ticker].loc[i,'a_Co'])*signals[ticker].loc[i,'Final Signal_L']-signals[ticker].loc[i,'a_Co']*signals[ticker].loc[i,'Final Signal_S']
    else:
      signals[ticker].loc[i,'Final Signal']=(signals[ticker].loc[i,'Final Signal_L']+signals[ticker].loc[i,'Final Signal_S'])/2
   #Smoothing the signal
  signals[ticker]['Final Signal_L']=signals[ticker]['Final Signal_L'].ewm(span=12).mean()
  signals[ticker]['Final Signal']=signals[ticker]['Final Signal'].ewm(span=12).mean()
  #Applying response function
  signals[ticker]['Final Signal_L']=response_func(signals[ticker]['Final Signal_L'])
  signals[ticker]['Final Signal']=response_func(signals[ticker]['Final Signal'])

for ticker in eq:
  plt.figure(figsize=(25,8))
  plt.plot(np.cumprod(1+signals[ticker]['Final Signal']*data_resampled_eq[ticker]['gearing']*data_resampled_eq[ticker][ticker])-1,label='Corrected')
  plt.plot(np.cumprod(1+signals[ticker]['Final Signal_L']*data_resampled_eq[ticker]['gearing']*data_resampled_eq[ticker][ticker])-1,label='Previous')
  prev_vol=(signals[ticker]['Final Signal_L']*data_resampled_eq[ticker]['gearing']*data_resampled_eq[ticker][ticker]).std()*np.sqrt(252)
  cor_vol=(signals[ticker]['Final Signal']*data_resampled_eq[ticker]['gearing']*data_resampled_eq[ticker][ticker]).std()*np.sqrt(252)
  print(cor_vol,prev_vol)
  plt.title(f'{ticker}')
  plt.legend()

for ticker in eq:
  plt.figure(figsize=(25,8))
  plt.plot(signals[ticker]['Final Signal']*data_resampled_eq[ticker]['gearing'],label='Corrected')
  plt.plot(signals[ticker]['Final Signal_L']*data_resampled_eq[ticker]['gearing'],label='Previous')
  plt.title(f'{ticker}')
  plt.legend()

color_dict = { 'Bull':'green', 'Bear':'red', 'Correction':'yellow', 'Rebound':'orange'}
for ticker in eq:
  plt.figure(figsize=(25,8))
  plt.scatter(signals[ticker]['Final Signal_L'],signals[ticker]['Final Signal_S'],color=[ color_dict[i] for i in signals[ticker]['State'] ])
  plt.xlabel('Long')
  plt.ylabel('Short')
  plt.title(f'{ticker}')

for ticker in eq:
  x_eq=pd.DataFrame(signals[ticker].loc[signals[ticker].State=='Bull']).index
  x_eq1=data_resampled_eq[ticker].loc[x_eq,ticker]*data_resampled_eq[ticker].loc[x_eq,'gearing']*data_resampled_eq[ticker].loc[x_eq,'Final Signal_S']
  plt.figure(figsize=(25,8))
  a=np.cumprod(1+data_resampled_eq[ticker].loc[x_eq,ticker]*data_resampled_eq[ticker].loc[x_eq,'gearing']*data_resampled_eq[ticker].loc[x_eq,'Final Signal_S'])[-1]-1
  b=np.cumprod(1+data_resampled_eq[ticker].loc[x_eq,ticker]*data_resampled_eq[ticker].loc[x_eq,'gearing']*data_resampled_eq[ticker].loc[x_eq,'Final Signal_L'])[-1]-1
  print(ticker,a-b)
  print(a)
  print(b)
  plt.figure(figsize=(25,8))
  plt.scatter(x_eq,x_eq1)
  plt.title(f'{ticker}')



data_resampled_cur={}
data_cur={}
portfolio_df=pd.DataFrame()
fp1=pd.DataFrame()
list_vol=[]

for ticker in curncy:
  #data consolidation
  data_cur[ticker]=pd.DataFrame(cur_p.loc[:,ticker])
  data_resampled_cur[ticker] = data_cur[ticker]
  data_resampled_cur[ticker][f'Daily Returns_lag{1}']=data_resampled_cur[ticker][ticker].shift(1)
  data_resampled_cur[ticker][f'Daily Returns_lag{20}']=(data_resampled_cur[ticker][f'Daily Returns_lag{1}']).rolling(window=20).mean()
  data_resampled_cur[ticker][f'Vol']=calc_vol(data_resampled_cur[ticker][f'Daily Returns_lag{1}'])['Vol']

  data_resampled_cur[ticker][f'Daily_signal_lag{20}']=(data_resampled_cur[ticker][f'Daily Returns_lag{20}']/(data_resampled_cur[ticker][f'Vol']))*np.sqrt(20)
  data_resampled_cur[ticker][f'Daily_signal_lag_norm{20}'] = np.clip(data_resampled_cur[ticker][f'Daily_signal_lag{20}'], -2, 2)
  #Gearing for the short term trend
  data_resampled_cur[ticker][f'gearing_20']=0.08/(np.sqrt(252)*data_resampled_cur[ticker][f'Vol'])

  #Gearing for the combined signal
  data_resampled_cur[ticker][f'gearing'] = 0.3/(np.sqrt(252)*data_resampled_cur[ticker][f'Vol'])

  #Gearing up the short term signal
  data_resampled_cur[ticker][f'Daily_signal_lag_norm{20}']=data_resampled_cur[ticker][f'Daily_signal_lag_norm{20}']*data_resampled_cur[ticker][f'gearing_20']

  for i in lags1:
    data_resampled_cur[ticker][f'Daily Returns_lag{i}']=(data_resampled_cur[ticker][f'Daily Returns_lag{1}']).rolling(window=i).mean()
  for i in lags2:
    data_resampled_cur[ticker][f'Daily Returns_lag{i}']=(data_resampled_cur[ticker][f'Daily Returns_lag{1}']).rolling(window=i).mean()
  data_resampled_cur[ticker]=data_resampled_cur[ticker].dropna()
  #Calculating Signals
  for i in lags1:
    data_resampled_cur[ticker][f'Daily_signal_lag{i}']=(data_resampled_cur[ticker][f'Daily Returns_lag{i}']/(data_resampled_cur[ticker][f'Vol']))*np.sqrt(i)
    data_resampled_cur[ticker][f'Daily_signal_lag_norm{i}'] = np.clip(data_resampled_cur[ticker][f'Daily_signal_lag{i}'], -2, 2)
  for i in lags2:
    data_resampled_cur[ticker][f'Daily_signal_lag{i}']=(data_resampled_cur[ticker][f'Daily Returns_lag{i}']/(data_resampled_cur[ticker][f'Vol']))*np.sqrt(i)
    data_resampled_cur[ticker][f'Daily_signal_lag_norm{i}'] = np.clip(data_resampled_cur[ticker][f'Daily_signal_lag{i}'], -2, 2)


  #Combining the signal
  cs1=pd.DataFrame(data_resampled_cur[ticker][f'Daily_signal_lag_norm{lags1[0]}']*optimal_weights1[0]+data_resampled_cur[ticker][f'Daily_signal_lag_norm{lags1[1]}']*optimal_weights1[1]+data_resampled_cur[ticker][f'Daily_signal_lag_norm{lags1[2]}']*optimal_weights1[2]+data_resampled_cur[ticker][f'Daily_signal_lag_norm{lags1[3]}']*optimal_weights1[3]+data_resampled_cur[ticker][f'Daily_signal_lag_norm{lags1[4]}']*optimal_weights1[4],columns=['Final Signal_L'])
  cs2=pd.DataFrame(data_resampled_cur[ticker][f'Daily_signal_lag_norm{lags2[0]}']*optimal_weights2[0]+data_resampled_cur[ticker][f'Daily_signal_lag_norm{lags2[1]}']*optimal_weights2[1]+data_resampled_cur[ticker][f'Daily_signal_lag_norm{lags2[2]}']*optimal_weights2[2]+data_resampled_cur[ticker][f'Daily_signal_lag_norm{lags2[3]}']*optimal_weights2[3]+data_resampled_cur[ticker][f'Daily_signal_lag_norm{lags2[4]}']*optimal_weights2[4],columns=['Final Signal_S'])

  cs1=signal_boost(cs1,vix_f)
  cs2=signal_boost(cs2,vix_f)

  data_resampled_cur[ticker]=pd.concat([data_resampled_cur[ticker],cs1],axis=1)
  data_resampled_cur[ticker]=pd.concat([data_resampled_cur[ticker],cs2],axis=1)

for ticker in curncy:
  signals[ticker]=pd.DataFrame(data_resampled_cur[ticker][['Final Signal_L','Final Signal_S',f'{ticker}']])
  signals[ticker]['State']=[0]*len(signals[ticker])
  signals[ticker]['Final Signal']=[0]*len(signals[ticker])

  signals[ticker]['P(Bu)']=[0]*len(signals[ticker])
  signals[ticker]['P(Be)']=[0]*len(signals[ticker])
  signals[ticker]['P(Bu|Be)']=[0]*len(signals[ticker])

  #Calcualting returns squared
  signals[ticker][f'{ticker}_R2']=signals[ticker][f'{ticker}']**2

  signals[ticker]['R2|Bu or Be']=[0]*len(signals[ticker])
  signals[ticker]['R2|Co']=[0]*len(signals[ticker])
  signals[ticker]['R2|Re']=[0]*len(signals[ticker])

  signals[ticker]['R|Co']=[0]*len(signals[ticker])
  signals[ticker]['R|Re']=[0]*len(signals[ticker])
  signals[ticker]['R|Bu']=[0]*len(signals[ticker])
  signals[ticker]['R|Be']=[0]*len(signals[ticker])
  for i in signals[ticker].index:
    if(np.sign(signals[ticker].loc[i,'Final Signal_L'])==np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])>=0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])>0):
      signals[ticker].loc[i,'State']='Bull'
      signals[ticker].loc[i,'P(Bu)']=1
      signals[ticker].loc[i,'P(Bu|Be)']=1
      signals[ticker].loc[i,'R2|Bu or Be']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Bu']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])==np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])<0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])<0):
      signals[ticker].loc[i,'State']='Bear'
      signals[ticker].loc[i,'P(Be)']=1
      signals[ticker].loc[i,'P(Bu|Be)']=1
      signals[ticker].loc[i,'R2|Bu or Be']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Be']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])!=np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])>0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])<0):
      signals[ticker].loc[i,'State']='Correction'
      signals[ticker].loc[i,'R2|Co']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Co']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])!=np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])<0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])>=0):
      signals[ticker].loc[i,'State']='Rebound'
      signals[ticker].loc[i,'R2|Re']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Re']=signals[ticker].loc[i,f'{ticker}']

  signals[ticker]['R|Co']=signals[ticker]['R|Co'].rolling(window=630).mean().shift(1)
  signals[ticker]['R|Re']=signals[ticker]['R|Re'].rolling(window=630).mean().shift(1)
  signals[ticker]['R|Bu']=signals[ticker]['R|Bu'].rolling(window=630).mean().shift(1)
  signals[ticker]['R|Bu']=signals[ticker]['R|Bu'].rolling(window=630).mean().shift(1)

  signals[ticker]['R2|Bu or Be']=signals[ticker]['R2|Bu or Be'].rolling(window=630).mean().shift(1)
  signals[ticker]['R2|Co']=signals[ticker]['R2|Co'].rolling(window=630).mean().shift(1)
  signals[ticker]['R2|Re']=signals[ticker]['R2|Re'].rolling(window=630).mean().shift(1)

  signals[ticker]['P(Bu)']=signals[ticker]['P(Bu)'].rolling(window=630).mean().shift(1)
  signals[ticker]['P(Be)']=signals[ticker]['P(Be)'].rolling(window=630).mean().shift(1)
  signals[ticker]['P(Bu|Be)']=signals[ticker]['P(Bu|Be)'].rolling(window=630).mean().shift(1)

  signals[ticker]=signals[ticker].dropna()
  signals[ticker]['a_Co']=0.5*(1-(((signals[ticker]['R2|Bu or Be']*signals[ticker]['P(Bu|Be)'])/(signals[ticker]['R|Bu']*signals[ticker]['P(Bu)']-signals[ticker]['R|Be']*signals[ticker]['P(Be)']))*(signals[ticker]['R|Co']/signals[ticker]['R2|Co'])))
  signals[ticker]['a_Re']=0.5*(1+(((signals[ticker]['R2|Bu or Be']*signals[ticker]['P(Bu|Be)'])/(signals[ticker]['R|Bu']*signals[ticker]['P(Bu)']-signals[ticker]['R|Be']*signals[ticker]['P(Be)']))*(signals[ticker]['R|Re']/signals[ticker]['R2|Re'])))
  signals[ticker]['a_Co']=np.clip(signals[ticker]['a_Co'],0,1)
  signals[ticker]['a_Re']=np.clip(signals[ticker]['a_Re'],0,1)
  for i in signals[ticker].index:
    if signals[ticker].loc[i,'State']=='Rebound':
      signals[ticker].loc[i,'Final Signal']=(1-signals[ticker].loc[i,'a_Re'])*signals[ticker].loc[i,'Final Signal_L']*(-1)+signals[ticker].loc[i,'a_Re']*signals[ticker].loc[i,'Final Signal_S']
    elif signals[ticker].loc[i,'State']=='Correction':
      signals[ticker].loc[i,'Final Signal']=(1-signals[ticker].loc[i,'a_Co'])*signals[ticker].loc[i,'Final Signal_L']-signals[ticker].loc[i,'a_Co']*signals[ticker].loc[i,'Final Signal_S']
    else:
      signals[ticker].loc[i,'Final Signal']=(signals[ticker].loc[i,'Final Signal_L']+signals[ticker].loc[i,'Final Signal_S'])/2
   #Smoothing the signal
  signals[ticker]['Final Signal_L']=signals[ticker]['Final Signal_L'].ewm(span=12).mean()
  signals[ticker]['Final Signal']=signals[ticker]['Final Signal'].ewm(span=12).mean()
  #Applying response function
  signals[ticker]['Final Signal_L']=response_func(signals[ticker]['Final Signal_L'])
  signals[ticker]['Final Signal']=response_func(signals[ticker]['Final Signal'])

for ticker in curncy:
  plt.figure(figsize=(25,8))
  plt.plot(np.cumprod(1+signals[ticker]['Final Signal']*data_resampled_cur[ticker]['gearing']*data_resampled_cur[ticker][ticker])-1,label='Corrected')
  plt.plot(np.cumprod(1+signals[ticker]['Final Signal_L']*data_resampled_cur[ticker]['gearing']*data_resampled_cur[ticker][ticker])-1,label='Previous')
  prev_vol=(signals[ticker]['Final Signal_L']*data_resampled_cur[ticker]['gearing']*data_resampled_cur[ticker][ticker]).std()*np.sqrt(252)
  cor_vol=(signals[ticker]['Final Signal']*data_resampled_cur[ticker]['gearing']*data_resampled_cur[ticker][ticker]).std()*np.sqrt(252)
  print(cor_vol,prev_vol)
  plt.title(f'{ticker}')
  plt.legend()

color_dict = { 'Bull':'green', 'Bear':'red', 'Correction':'yellow', 'Rebound':'orange'}
for ticker in curncy:
  plt.figure(figsize=(25,8))
  plt.scatter(signals[ticker]['Final Signal_L'],signals[ticker]['Final Signal_S'],color=[ color_dict[i] for i in signals[ticker]['State'] ])
  plt.xlabel('Long')
  plt.ylabel('Short')
  plt.title(f'{ticker}')

for ticker in curncy:
  x_cur=pd.DataFrame(signals[ticker].loc[signals[ticker].State=='Bear']).index
  x_cur1=data_resampled_cur[ticker].loc[x_cur,ticker]*data_resampled_cur[ticker].loc[x_cur,'gearing']*data_resampled_cur[ticker].loc[x_cur,'Final Signal_S']
  plt.figure(figsize=(25,8))
  a=np.cumprod(1+data_resampled_cur[ticker].loc[x_cur,ticker]*data_resampled_cur[ticker].loc[x_cur,'gearing']*data_resampled_cur[ticker].loc[x_cur,'Final Signal_S'])[-1]-1
  b=np.cumprod(1+data_resampled_cur[ticker].loc[x_cur,ticker]*data_resampled_cur[ticker].loc[x_cur,'gearing']*data_resampled_cur[ticker].loc[x_cur,'Final Signal_L'])[-1]-1
  print(ticker,a-b)
  print(a)
  print(b)
  plt.figure(figsize=(25,8))
  plt.scatter(x_cur,x_cur1)
  plt.title(f'{ticker}')

data_resampled_fi={}
data_fi={}
portfolio_df=pd.DataFrame()
fp1=pd.DataFrame()
list_vol=[]

for ticker in fi:
  #data consolidation
  data_fi[ticker]=pd.DataFrame(fi_p.loc[:,ticker])
  data_resampled_fi[ticker] = data_fi[ticker]
  data_resampled_fi[ticker][f'Daily Returns_lag{1}']=data_resampled_fi[ticker][ticker].shift(1)
  data_resampled_fi[ticker][f'Daily Returns_lag{20}']=(data_resampled_fi[ticker][f'Daily Returns_lag{1}']).rolling(window=20).mean()
  data_resampled_fi[ticker][f'Vol']=calc_vol(data_resampled_fi[ticker][f'Daily Returns_lag{1}'])['Vol']

  data_resampled_fi[ticker][f'Daily_signal_lag{20}']=(data_resampled_fi[ticker][f'Daily Returns_lag{20}']/(data_resampled_fi[ticker][f'Vol']))*np.sqrt(20)
  data_resampled_fi[ticker][f'Daily_signal_lag_norm{20}'] = np.clip(data_resampled_fi[ticker][f'Daily_signal_lag{20}'], -2, 2)
  #Gearing for the short term trend
  data_resampled_fi[ticker][f'gearing_20']=0.08/(np.sqrt(252)*data_resampled_fi[ticker][f'Vol'])

  #Gearing for the combined signal
  data_resampled_fi[ticker][f'gearing'] = 0.3/(np.sqrt(252)*data_resampled_fi[ticker][f'Vol'])

  #Gearing up the short term signal
  data_resampled_fi[ticker][f'Daily_signal_lag_norm{20}']=data_resampled_fi[ticker][f'Daily_signal_lag_norm{20}']*data_resampled_fi[ticker][f'gearing_20']

  for i in lags1:
    data_resampled_fi[ticker][f'Daily Returns_lag{i}']=(data_resampled_fi[ticker][f'Daily Returns_lag{1}']).rolling(window=i).mean()
  for i in lags2:
    data_resampled_fi[ticker][f'Daily Returns_lag{i}']=(data_resampled_fi[ticker][f'Daily Returns_lag{1}']).rolling(window=i).mean()
  data_resampled_fi[ticker]=data_resampled_fi[ticker].dropna()
  #Calculating Signals
  for i in lags1:
    data_resampled_fi[ticker][f'Daily_signal_lag{i}']=(data_resampled_fi[ticker][f'Daily Returns_lag{i}']/(data_resampled_fi[ticker][f'Vol']))*np.sqrt(i)
    data_resampled_fi[ticker][f'Daily_signal_lag_norm{i}'] = np.clip(data_resampled_fi[ticker][f'Daily_signal_lag{i}'], -2, 2)
  for i in lags2:
    data_resampled_fi[ticker][f'Daily_signal_lag{i}']=(data_resampled_fi[ticker][f'Daily Returns_lag{i}']/(data_resampled_fi[ticker][f'Vol']))*np.sqrt(i)
    data_resampled_fi[ticker][f'Daily_signal_lag_norm{i}'] = np.clip(data_resampled_fi[ticker][f'Daily_signal_lag{i}'], -2, 2)


  #Combining the signal
  cs1=pd.DataFrame(data_resampled_fi[ticker][f'Daily_signal_lag_norm{lags1[0]}']*optimal_weights1[0]+data_resampled_fi[ticker][f'Daily_signal_lag_norm{lags1[1]}']*optimal_weights1[1]+data_resampled_fi[ticker][f'Daily_signal_lag_norm{lags1[2]}']*optimal_weights1[2]+data_resampled_fi[ticker][f'Daily_signal_lag_norm{lags1[3]}']*optimal_weights1[3]+data_resampled_fi[ticker][f'Daily_signal_lag_norm{lags1[4]}']*optimal_weights1[4],columns=['Final Signal_L'])
  cs2=pd.DataFrame(data_resampled_fi[ticker][f'Daily_signal_lag_norm{lags2[0]}']*optimal_weights2[0]+data_resampled_fi[ticker][f'Daily_signal_lag_norm{lags2[1]}']*optimal_weights2[1]+data_resampled_fi[ticker][f'Daily_signal_lag_norm{lags2[2]}']*optimal_weights2[2]+data_resampled_fi[ticker][f'Daily_signal_lag_norm{lags2[3]}']*optimal_weights2[3]+data_resampled_fi[ticker][f'Daily_signal_lag_norm{lags2[4]}']*optimal_weights2[4],columns=['Final Signal_S'])

  cs1=signal_boost(cs1,vix_f)
  cs2=signal_boost(cs2,vix_f)

  data_resampled_fi[ticker]=pd.concat([data_resampled_fi[ticker],cs1],axis=1)
  data_resampled_fi[ticker]=pd.concat([data_resampled_fi[ticker],cs2],axis=1)

for ticker in fi:
  signals[ticker]=pd.DataFrame(data_resampled_fi[ticker][['Final Signal_L','Final Signal_S',f'{ticker}']])
  signals[ticker]['State']=[0]*len(signals[ticker])
  signals[ticker]['Final Signal']=[0]*len(signals[ticker])

  signals[ticker]['P(Bu)']=[0]*len(signals[ticker])
  signals[ticker]['P(Be)']=[0]*len(signals[ticker])
  signals[ticker]['P(Bu|Be)']=[0]*len(signals[ticker])

  #Calcualting returns squared
  signals[ticker][f'{ticker}_R2']=signals[ticker][f'{ticker}']**2

  signals[ticker]['R2|Bu or Be']=[0]*len(signals[ticker])
  signals[ticker]['R2|Co']=[0]*len(signals[ticker])
  signals[ticker]['R2|Re']=[0]*len(signals[ticker])

  signals[ticker]['R|Co']=[0]*len(signals[ticker])
  signals[ticker]['R|Re']=[0]*len(signals[ticker])
  signals[ticker]['R|Bu']=[0]*len(signals[ticker])
  signals[ticker]['R|Be']=[0]*len(signals[ticker])
  for i in signals[ticker].index:
    if(np.sign(signals[ticker].loc[i,'Final Signal_L'])==np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])>=0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])>0):
      signals[ticker].loc[i,'State']='Bull'
      signals[ticker].loc[i,'P(Bu)']=1
      signals[ticker].loc[i,'P(Bu|Be)']=1
      signals[ticker].loc[i,'R2|Bu or Be']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Bu']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])==np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])<0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])<0):
      signals[ticker].loc[i,'State']='Bear'
      signals[ticker].loc[i,'P(Be)']=1
      signals[ticker].loc[i,'P(Bu|Be)']=1
      signals[ticker].loc[i,'R2|Bu or Be']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Be']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])!=np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])>0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])<0):
      signals[ticker].loc[i,'State']='Correction'
      signals[ticker].loc[i,'R2|Co']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Co']=signals[ticker].loc[i,f'{ticker}']

    elif(np.sign(signals[ticker].loc[i,'Final Signal_L'])!=np.sign(signals[ticker].loc[i,'Final Signal_S']))&(np.sign(signals[ticker].loc[i,'Final Signal_L'])<0)&(np.sign(signals[ticker].loc[i,'Final Signal_S'])>=0):
      signals[ticker].loc[i,'State']='Rebound'
      signals[ticker].loc[i,'R2|Re']=signals[ticker].loc[i,f'{ticker}_R2']
      signals[ticker].loc[i,'R|Re']=signals[ticker].loc[i,f'{ticker}']

  signals[ticker]['R|Co']=signals[ticker]['R|Co'].rolling(window=252).mean().shift(1)
  signals[ticker]['R|Re']=signals[ticker]['R|Re'].rolling(window=252).mean().shift(1)
  signals[ticker]['R|Bu']=signals[ticker]['R|Bu'].rolling(window=252).mean().shift(1)
  signals[ticker]['R|Bu']=signals[ticker]['R|Bu'].rolling(window=252).mean().shift(1)

  signals[ticker]['R2|Bu or Be']=signals[ticker]['R2|Bu or Be'].rolling(window=252).mean().shift(1)
  signals[ticker]['R2|Co']=signals[ticker]['R2|Co'].rolling(window=252).mean().shift(1)
  signals[ticker]['R2|Re']=signals[ticker]['R2|Re'].rolling(window=252).mean().shift(1)

  signals[ticker]['P(Bu)']=signals[ticker]['P(Bu)'].rolling(window=252).mean().shift(1)
  signals[ticker]['P(Be)']=signals[ticker]['P(Be)'].rolling(window=252).mean().shift(1)
  signals[ticker]['P(Bu|Be)']=signals[ticker]['P(Bu|Be)'].rolling(window=252).mean().shift(1)

  signals[ticker]=signals[ticker].dropna()
  signals[ticker]['a_Co']=0.5*(1-(((signals[ticker]['R2|Bu or Be']*signals[ticker]['P(Bu|Be)'])/(signals[ticker]['R|Bu']*signals[ticker]['P(Bu)']-signals[ticker]['R|Be']*signals[ticker]['P(Be)']))*(signals[ticker]['R|Co']/signals[ticker]['R2|Co'])))
  signals[ticker]['a_Re']=0.5*(1+(((signals[ticker]['R2|Bu or Be']*signals[ticker]['P(Bu|Be)'])/(signals[ticker]['R|Bu']*signals[ticker]['P(Bu)']-signals[ticker]['R|Be']*signals[ticker]['P(Be)']))*(signals[ticker]['R|Re']/signals[ticker]['R2|Re'])))
  signals[ticker]['a_Co']=np.clip(signals[ticker]['a_Co'],0,1)
  signals[ticker]['a_Re']=np.clip(signals[ticker]['a_Re'],0,1)
  for i in signals[ticker].index:
    if signals[ticker].loc[i,'State']=='Rebound':
      signals[ticker].loc[i,'Final Signal']=(1-signals[ticker].loc[i,'a_Re'])*signals[ticker].loc[i,'Final Signal_L']+signals[ticker].loc[i,'a_Re']*signals[ticker].loc[i,'Final Signal_S']
    elif signals[ticker].loc[i,'State']=='Correction':
      signals[ticker].loc[i,'Final Signal']=(1-signals[ticker].loc[i,'a_Co'])*signals[ticker].loc[i,'Final Signal_L']+signals[ticker].loc[i,'a_Co']*signals[ticker].loc[i,'Final Signal_S']
    else:
      signals[ticker].loc[i,'Final Signal']=(2/3)*signals[ticker].loc[i,'Final Signal_L']+(1/3)*signals[ticker].loc[i,'Final Signal_S']
   #Smoothing the signal
  signals[ticker]['Final Signal_L']=signals[ticker]['Final Signal_L'].ewm(span=12).mean()
  signals[ticker]['Final Signal']=signals[ticker]['Final Signal'].ewm(span=12).mean()
  #Applying response function
  signals[ticker]['Final Signal_L']=response_func(signals[ticker]['Final Signal_L'])
  signals[ticker]['Final Signal']=response_func(signals[ticker]['Final Signal'])

for ticker in fi:
  plt.figure(figsize=(25,8))
  plt.plot(np.cumprod(1+signals[ticker]['Final Signal']*data_resampled_fi[ticker]['gearing']*data_resampled_fi[ticker][ticker])-1,label='Corrected')
  plt.plot(np.cumprod(1+signals[ticker]['Final Signal_L']*data_resampled_fi[ticker]['gearing']*data_resampled_fi[ticker][ticker])-1,label='Previous')
  prev_vol=(signals[ticker]['Final Signal_L']*data_resampled_fi[ticker]['gearing']*data_resampled_fi[ticker][ticker]).std()*np.sqrt(252)
  cor_vol=(signals[ticker]['Final Signal']*data_resampled_fi[ticker]['gearing']*data_resampled_fi[ticker][ticker]).std()*np.sqrt(252)
  print(cor_vol,prev_vol)
  plt.title(f'{ticker}')
  plt.legend()

plt.figure(figsize=(25,8))
plt.plot(signals[ticker]['a_Re'])